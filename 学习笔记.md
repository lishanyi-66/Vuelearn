### Vue事件处理

#### Vue中的事件修饰符

* prevent:阻止默认事件（常用）
* stop:阻止事件冒泡
* once:事件只触发一次
* capture:使用事件的捕获模式
* self:只有event.target是当前操作的元素四才触发事件
* passive:事件的默认行为立即执行，无需等待事件回调执行完毕；

#### Vue中的键盘事件

* Vue中未提供别名的按键，可以使用按键原始的Key值去绑定，但是注意要转为kebab-case（短横线命名）
* 系统修饰键：ctrl 、alt、shift、meta
   * 配合keyup使用“按下修饰键的同时，再按下其他键，随后释放其他键，事件才能被楚大
   * 配合keydown 使用：正常触发事件
* 也可以使用keyCode去指定具体的按键（不推荐）
* Vue.config.keyCodes.自定义键名=键码 ，可以定制按键别名

### Vue 计算属性

##### 计算属性实现

* 定义：要用的属性不存在，要通过已有属性计算得到
* 原理：借助了Object.defineoperty 方法提供getter和setter
* get函数什么时候执行
  * 1.初次读取时会执行一次
  * 2.当依赖的数据发生变化时会被调用
* 优势：与methods实现相比，直接读取使用即可
* 备注：
  * 1.计算属性最终会出现在VM上，直接读取即可
  * 2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据

### watch  监视 深度监视

#### 深度监视：

* Vue中的watch 默认不监测对象的内部值得变化
* 配置deep:true可以监测对象内部值得改变

备注

* Vue自身可以监测对象内部值得改变，但Vue提供的watch默认不可以
* 使用watch时根据数据的具体结构，决定是否采用深度监视

```vue
watch:{
isHot:{
immediate:true, //初始化时让handle调用下
deep:true,//深度监视
handler(newValue,oldValue){
console.log('isHot被修改了'，newValue,oldValue)
}
}
}
```

### computed和watch之间的区别
* computed能完成的功能那个，watch也能完成
* watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作

##### 两个重要的小原则
* 所内Vue管理的函数，最好写成普通函数，这样this的指向才是vm或者组件实例对象
* 所有不被Vue所管理的函数（定时器的回调函数，ajax的回调函数等）最好写成箭头函数，这样this的指向才是vm或者组件实例对象

***
### 动态绑定class样式
* 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定
```
<div :class="mood">{{name}}</div>
data:{
  mood:normal
}
* 绑定class样式--数组写法，适用于：要绑定的样式个数不确定，名字不确定
```
<div :class='classArr'>{{name}}</div>
data:{
  classArr:[arr1,arr2,arr3]
}

* 绑定class样式--对象的写法，适用于：要绑定的样式个数确定，名字也确定，但是要动态决定用不用
```
<div :class='classObj'>{{name}}</div>
data:{
  classObj:{
    Obj1:false,
    Obj2:false,
  }
}
